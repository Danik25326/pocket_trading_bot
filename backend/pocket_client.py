
import asyncio
import logging
from config import Config

logger = logging.getLogger("signal_bot")


class PocketOptionClient:
    def __init__(self):
        self.client = None
        self.connected = False
        self._initialized = False
    
    async def initialize(self):
        if self._initialized:
            return self
        
        try:
            # –û—Ç—Ä–∏–º—É—î–º–æ SSID –∑ –∫–æ–Ω—Ñ—ñ–≥—É—Ä–∞—Ü—ñ—ó
            ssid = Config.POCKET_SSID
            if not ssid:
                logger.error("‚ùå SSID –Ω–µ –∑–Ω–∞–π–¥–µ–Ω–æ!")
                return self
            
            logger.info(f"üîó –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è PocketOption –∫–ª—ñ—î–Ω—Ç–∞ (Demo: {Config.POCKET_DEMO})...")
            
            # –Ü–º–ø–æ—Ä—Ç—É—î–º–æ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ–≥–æ –∫–ª—ñ—î–Ω—Ç–∞
            try:
                from pocketoptionapi_async import AsyncPocketOptionClient
            except ImportError as e:
                logger.error(f"‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è —ñ–º–ø–æ—Ä—Ç—É–≤–∞—Ç–∏ pocketoptionapi_async: {e}")
                logger.info("‚ÑπÔ∏è –í—Å—Ç–∞–Ω–æ–≤—ñ—Ç—å –±—ñ–±–ª—ñ–æ—Ç–µ–∫—É: pip install pocketoptionapi-async==2.0.1")
                return self
            
            # –§–æ—Ä–º–∞—Ç—É—î–º–æ SSID
            if not ssid.startswith('42["auth"'):
                logger.info("–§–æ—Ä–º–∞—Ç—É—î–º–æ SSID...")
                # –î–ª—è –¥–µ–º–æ —Ä–µ–∂–∏–º—É
                is_demo = 1 if Config.POCKET_DEMO else 0
                ssid = f'42["auth",{{"session":"{ssid}","isDemo":{is_demo},"uid":102582216,"platform":1}}]'
            
            logger.debug(f"SSID (–ø–µ—Ä—à—ñ 100 —Å–∏–º–≤–æ–ª—ñ–≤): {ssid[:100]}...")
            
            # –°—Ç–≤–æ—Ä—é—î–º–æ –∫–ª—ñ—î–Ω—Ç–∞
            self.client = AsyncPocketOptionClient(
                ssid=ssid,
                enable_logging=False
            )
            
            self._initialized = True
            logger.info("‚úÖ –ö–ª—ñ—î–Ω—Ç —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–æ")
            return self
        
        except Exception as e:
            logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—ó PocketOption: {e}")
            import traceback
            logger.error(f"–î–µ—Ç–∞–ª—ñ: {traceback.format_exc()}")
            return self
    
async def connect(self):
    try:
        if not self._initialized:
            await self.initialize()

        if not self.client:
            logger.error("‚ùå –ö–ª—ñ—î–Ω—Ç –Ω–µ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–æ–≤–∞–Ω–∏–π")
            return False

        logger.info("üîó –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ PocketOption...")
        # –°–∫–∏–¥–∞—î–º–æ —Å—Ç–∞–Ω –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –ø–µ—Ä–µ–¥ —Å–ø—Ä–æ–±–æ—é
        self.connected = False
        await self.client.connected()

        # –ß–µ–∫–∞—î–º–æ –Ω–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —Ç—Ä–æ—Ö–∏ –¥–æ–≤—à–µ
        for i in range(5):
            await asyncio.sleep(1)
            if hasattr(self.client, 'connected') and self.client.connected:
                self.connected = True
                logger.info("‚úÖ –£—Å–ø—ñ—à–Ω–æ –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ –¥–æ PocketOption!")
                return True
            else:
                logger.debug(f"–û—á—ñ–∫—É–≤–∞–Ω–Ω—è –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è... {i+1}/5")

        logger.error("‚ùå –ù–µ –≤–¥–∞–ª–æ—Å—è –ø—ñ–¥—Ç–≤–µ—Ä–¥–∏—Ç–∏ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –ø—ñ—Å–ª—è 5 —Å–µ–∫—É–Ω–¥ –æ—á—ñ–∫—É–≤–∞–Ω–Ω—è.")
        self.connected = False
        return False

    except Exception as e:
        logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è: {e}")
        self.connected = False
        return False
    
    async def get_candles(self, asset, timeframe, count=30):
        """–û—Ç—Ä–∏–º–∞–Ω–Ω—è —Å–≤—ñ—á–æ–∫ –¥–ª—è –∞–∫—Ç–∏–≤—É"""
        try:
            if not self.connected:
                logger.warning("–ù–µ –ø—ñ–¥–∫–ª—é—á–µ–Ω–æ, —Å–ø—Ä–æ–±—É—é –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è...")
                if not await self.connect():
                    logger.error("–ù–µ –≤–¥–∞–ª–æ—Å—è –ø—ñ–¥–∫–ª—é—á–∏—Ç–∏—Å—è")
                    return None
            
            logger.info(f"üìä –ó–∞–ø–∏—Ç —Å–≤—ñ—á–æ–∫ –¥–ª—è {asset} (—Ç–∞–π–º—Ñ—Ä–µ–π–º: {timeframe}—Å, –∫—ñ–ª—å–∫—ñ—Å—Ç—å: {count})")
            
            # –û—Ç—Ä–∏–º—É—î–º–æ —Å–≤—ñ—á–∫–∏
            candles = await self.client.get_candles(
                asset=asset,
                timeframe=timeframe,
                count=count
            )
            
            if candles:
                logger.info(f"‚úÖ –û—Ç—Ä–∏–º–∞–Ω–æ {len(candles)} —Å–≤—ñ—á–æ–∫ –¥–ª—è {asset}")
                return candles
            else:
                logger.warning(f"‚ö†Ô∏è –ù–µ –æ—Ç—Ä–∏–º–∞–Ω–æ —Å–≤—ñ—á–æ–∫ –¥–ª—è {asset}")
                return None
        
        except Exception as e:
            logger.error(f"‚ùå –ü–æ–º–∏–ª–∫–∞ –æ—Ç—Ä–∏–º–∞–Ω–Ω—è —Å–≤—ñ—á–æ–∫ –¥–ª—è {asset}: {e}")
            return None
    
    async def disconnect(self):
        try:
            if self.client and self.connected:
                await self.client.disconnect()
                self.connected = False
                logger.info("‚úÖ –í—ñ–¥–∫–ª—é—á–µ–Ω–æ –≤—ñ–¥ PocketOption")
                return True
            return False
        except Exception as e:
            logger.warning(f"–ü–æ–º–∏–ª–∫–∞ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è: {e}")
            return False
